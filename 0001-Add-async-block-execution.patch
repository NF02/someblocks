From d78a7af1ca024ebb51831622a2614e43610d1397 Mon Sep 17 00:00:00 2001
From: krypek <115574014+krypciak@users.noreply.github.com>
Date: Sun, 20 Nov 2022 20:22:25 +0100
Subject: [PATCH] Add async block execution

---
 someblocks.c | 121 +++++++++++++++++++++++++++++++++++++++------------
 1 file changed, 92 insertions(+), 29 deletions(-)

diff --git a/someblocks.c b/someblocks.c
index 8103164..3f4ed6f 100644
--- a/someblocks.c
+++ b/someblocks.c
@@ -1,11 +1,13 @@
 #define _POSIX_C_SOURCE 200809L
-#include<stdlib.h>
-#include<stdio.h>
-#include<string.h>
-#include<unistd.h>
-#include<fcntl.h>
-#include<errno.h>
-#include<signal.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <time.h>
 #ifdef __OpenBSD__
 #define SIGPLUS			SIGUSR1+1
 #define SIGMINUS		SIGUSR1-1
@@ -21,14 +23,19 @@
 typedef struct {
 	char* icon;
 	char* command;
-	unsigned int interval;
+	float interval;
 	unsigned int signal;
 } Block;
+
+typedef struct {
+    Block *block;
+    unsigned int i;
+} ThreadData;
+
 #ifndef __OpenBSD__
 void dummysighandler(int num);
 #endif
 void sighandler(int num);
-void getcmds(int time);
 void getsigcmds(unsigned int signal);
 void setupsignals();
 void sighandler(int signum);
@@ -39,6 +46,8 @@ void pstdout();
 void psomebar();
 static void (*writestatus) () = psomebar;
 
+void *threadblock(void *data);
+
 #include "blocks.h"
 
 static char statusbar[LENGTH(blocks)][CMDLENGTH] = {0};
@@ -47,17 +56,22 @@ static int statusContinue = 1;
 static int returnStatus = 0;
 static char somebarPath[128];
 static int somebarFd = -1;
+// block threads
+static pthread_t threads[LENGTH(blocks)];
+static pthread_mutex_t lock;
 
 //opens process *cmd and stores output in *output
 void getcmd(const Block *block, char *output)
 {
-	strcpy(output, block->icon);
+    char *output1 = malloc(sizeof(char) * CMDLENGTH);
+
+	strcpy(output1, block->icon);
 	FILE *cmdf = popen(block->command, "r");
 	if (!cmdf)
 		return;
 	int i = strlen(block->icon);
-	fgets(output+i, CMDLENGTH-i-delimLen, cmdf);
-	i = strlen(output);
+	fgets(output1+i, CMDLENGTH-i-delimLen, cmdf);
+	i = strlen(output1);
 	if (i == 0) {
 		//return if block and command output are both empty
 		pclose(cmdf);
@@ -65,22 +79,74 @@ void getcmd(const Block *block, char *output)
 	}
 	if (delim[0] != '\0') {
 		//only chop off newline if one is present at the end
-		i = output[i-1] == '\n' ? i-1 : i;
-		strncpy(output+i, delim, delimLen); 
+		i = output1[i-1] == '\n' ? i-1 : i;
+		strncpy(output1+i, delim, delimLen); 
 	}
 	else
-		output[i++] = '\0';
+		output1[i++] = '\0';
+
+    // lock 
+    pthread_mutex_lock(&lock);
+    strcpy(output, output1);
+    // unlock
+    pthread_mutex_unlock(&lock);
+
 	pclose(cmdf);
+
+    free(output1);
 }
 
-void getcmds(int time)
+void startthreads(void)
 {
-	const Block* current;
+    ThreadData *data = malloc(LENGTH(blocks)*sizeof(ThreadData));
+    const Block* current;
 	for (unsigned int i = 0; i < LENGTH(blocks); i++) {
 		current = blocks + i;
-		if ((current->interval != 0 && time % current->interval == 0) || time == -1)
-			getcmd(current,statusbar[i]);
-	}
+        data[i] = (ThreadData){.block = current, .i = i};
+        // start thread
+        pthread_create(&threads[i], NULL, threadblock, (void *)&data[i]);
+    }
+}
+
+// sleep tms miliseconds
+int msleep(long tms)
+{
+    struct timespec ts;
+    int ret;
+
+    if (tms < 0)
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    ts.tv_sec = tms / 1000;
+    ts.tv_nsec = (tms % 1000) * 1000000;
+
+    do {
+        ret = nanosleep(&ts, &ts);
+    } while (ret && errno == EINTR);
+
+    return ret;
+}
+
+void *threadblock(void *data)
+{
+    ThreadData *data1 = (ThreadData*) data;
+    const Block *block = data1->block;
+    while(1) {
+        getcmd(block, statusbar[data1->i]);
+        writestatus();
+    
+        // sleep block->interval in sections of 0.5s
+        // in case someblocks gets killed
+        unsigned int sleep = block->interval * 1000;
+        for(int i = 0; i < block->interval * 2; i++) {
+            if(statusContinue == 0) break;
+            msleep(500);
+        }
+        if(statusContinue == 0) break;
+    }
 }
 
 void getsigcmds(unsigned int signal)
@@ -150,15 +216,12 @@ void psomebar()
 void statusloop()
 {
 	setupsignals();
-	int i = 0;
-	getcmds(-1);
-	while (1) {
-		getcmds(i++);
-		writestatus();
-		if (!statusContinue)
-			break;
-		sleep(1.0);
-	}
+    
+    startthreads();  
+
+    for(int i = 0; i < LENGTH(blocks); i++) {
+        pthread_join(threads[i], NULL);
+    }
 }
 
 #ifndef __OpenBSD__
-- 
2.38.1

